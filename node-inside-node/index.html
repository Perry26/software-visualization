<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Document</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
  </head>
  <body>
    <script>
      run();

      function run() {
        const PADDING = 3;
        const nodes = [
          { id: "node1", level: 1 },
          { id: "node2", level: 1 },
          {
            id: "node3",
            level: 1,
            members: [
              {
                id: "member1",
                level: 2,
                members: [
                  {
                    id: "anak1",
                    level: 3,
                  },
                  {
                    id: "anak2",
                    level: 3,
                  },
                ],
              },
              {
                id: "member2",
                level: 2,
              },
              {
                id: "member3",
                level: 2,
              },
            ],
          },
        ];

        const links = [
          { source: "node1", target: "node2" },
          { source: "node2", target: "node3" },
          { source: "member2", target: "member1" },
          { source: "member2", target: "node1" },
        ];
        const width = 500; // window.innerWidth;
        const height = 400; // window.innerHeight;
        const svg = d3
          .select("body")
          .append("svg")
          .attr("width", width)
          .attr("height", height)
          .call(
            d3
              .zoom()
              .scaleExtent([1 / 2, 8])
              .on("zoom", zoomed)
          );

        let allSimulation = [];

        let simulation = d3.forceSimulation(nodes);
        simulation.force("charge", d3.forceManyBody().strength(-300));
        simulation.force("center", d3.forceCenter(width / 2, height / 2));
        simulation.force("x", d3.forceX(width / 2));
        simulation.force("y", d3.forceY(height / 2));
        simulation.on("tick", function ticked() {
          // calculate nodes width and height, x and y. only do this calculation once, on master simulation
          console.log(flattenedNode);
          for (let i = 0; i < flattenedNode.length; i++) {
            if (flattenedNode[i].members) {
              let members = flattenedNode[i].members;
              // members location is relative to the parent.
              let minX = members[0].x + members[0].cx;
              let maxX = members[0].x + members[0].cx + members[0].width;
              let minY = members[0].y + members[0].cy;
              let maxY = members[0].y + members[0].cy + members[0].height;

              for (let j = 0; j < members.length; j++) {
                if (members[j].x + members[j].cx < minX) {
                  minX = members[j].x;
                }
                if (members[j].x + members[j].cx + members[j].width > maxX) {
                  maxX = members[j].x + members[j].cx + members[j].width;
                }
                if (members[j].y + members[j].cy < minY) {
                  minY = members[j].y + members[j].cy;
                }
                if (members[j].y + members[j].cy + members[j].height > maxY) {
                  maxY = members[j].y + members[j].cy + members[j].height;
                }
              }

              flattenedNode[i].width = maxX - minX + PADDING * 2;
              flattenedNode[i].height = maxY - minY + PADDING * 2;
              // stands for calculated x and y.
              flattenedNode[i].cx = minX - PADDING;
              flattenedNode[i].cy = minY - PADDING;
            } else {
              flattenedNode[i].width = 10;
              flattenedNode[i].height = 10;
              //   stands for calculated x and y.
              flattenedNode[i].cx = 0;
              flattenedNode[i].cy = 0;
            }
          }

          containerElement.attr("transform", (d) => {
            return `translate(${d.x},${d.y})`;
          });
          nodeElements.attr("width", (d) => d.width).attr("height", (d) => d.height);
          // cannot use below as this wouldn't move the children of that group, which is the subgraph

          nodeElements.attr("x", (d) => d.cx).attr("y", (d) => d.cy);
        });

        allSimulation.push(simulation);

        // flatten node

        let flattenedNode = flattenNode(nodes);

        const canvas = svg.append("g");
        let containerElement = canvas
          .append("g")
          .selectAll("g")
          .data(nodes)
          .enter()
          .append("g")
          .attr("class", "nodes")
          .attr("id", (d) => d.id);

        containerElement.call(
          d3
            .drag()
            .on("start", (d) => {
              onDragStart(d, allSimulation);
            })
            .on("drag", (d) => {
              onDrag(d, allSimulation);
            })
            .on("end", (d) => {
              onDragEnd(d, allSimulation);
            })
        );
        let nodeElements = containerElement.append("rect").attr("x", 0).attr("y", 0).attr("width", 10).attr("height", 10).attr("fill", "red").attr("fill-opacity", "0.1");

        let linkElements = canvas.selectAll("line.link").data(links).enter().append("line").style("stroke", "blue").attr("class", "link");

        let linkSimulation = d3
          .forceSimulation(flattenedNode)
          .force(
            "link",
            d3
              .forceLink(links)
              .id((d) => {
                return d.id;
              })
              .strength(0)
          )
          .on("tick", (e) => {
            linkElements
              .attr("x1", (d) => {
                // change to global coordinates.
                let result = d.source.x;

                let temp = d.source;
                while (temp.parent) {
                  result += temp.parent.x;
                  temp = temp.parent;
                }

                return result;
              })
              .attr("y1", (d) => {
                // change to global coordinates.
                let result = d.source.y;

                let temp = d.source;
                while (temp.parent) {
                  result += temp.parent.y;
                  temp = temp.parent;
                }

                return result;
              })
              .attr("x2", (d) => {
                // change to global coordinates.
                let result = d.target.x;

                let temp = d.target;
                while (temp.parent) {
                  result += temp.parent.x;
                  temp = temp.parent;
                }

                return result;
              })
              .attr("y2", (d) => {
                // change to global coordinates.
                let result = d.target.y;

                let temp = d.target;
                while (temp.parent) {
                  result += temp.parent.y;
                  temp = temp.parent;
                }

                return result;
              });
          });

        allSimulation.push(linkSimulation);

        // create inner simulation.
        for (let i = 0; i < nodes.length; i++) {
          if (nodes[i].members) {
            createInnerSimulation(nodes[i].members, canvas, allSimulation, nodes[i]);
          }
        }

        function zoomed() {
          canvas.attr("transform", d3.event.transform);
        }

        
      }
      function onDragStart(d, allSimulation) {
        if (!d3.event.active) {
          allSimulation.forEach((simul) => {
            simul.alphaTarget(0.5).restart();
          });
        }
      }

      function onDrag(d, allSimulation) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
      }

      function onDragEnd(d, allSimulation) {
        if (!d3.event.active) {
          allSimulation.forEach((simul) => {
            simul.alphaTarget(0).restart();
          });
        }
        d.fx = null;
        d.fy = null;
      }

      function createInnerSimulation(nodes, canvas, allSimulation, parentNode) {
        console.log(nodes);
        // use this instead of forEach so that it is passed by reference.

        // bind for easy reference.
        for (let i = 0; i < nodes.length; i++) {
          nodes[i].parent = parentNode;
        }

        const innerSimulation = d3.forceSimulation(nodes);
        innerSimulation.force("charge", d3.forceManyBody().strength(-30));
        innerSimulation.force("x", d3.forceX());
        innerSimulation.force("y", d3.forceY());

        allSimulation.push(innerSimulation);

        const parentElement = canvas.select(`#${parentNode.id}`).append("g");
        let membersContainerElement = parentElement
          .selectAll("g")
          .data(nodes)
          .enter()
          .append("g")
          .attr("class", "node")
          .attr("id", (d) => d.id);

        membersContainerElement.call(
          d3
            .drag()
            .on("start", (d) => {
              onDragStart(d, allSimulation);
            })
            .on("drag", (d) => {
              onDrag(d, allSimulation);
            })
            .on("end", (d) => {
              onDragEnd(d, allSimulation);
            })
        );
        let memberElements = membersContainerElement.append("rect").attr("x", 0).attr("y", 0).attr("width", 5).attr("height", 5).style("fill", "green").attr("fill-opacity", "0.2");

        innerSimulation.on("tick", function ticked() {
          membersContainerElement.attr("transform", (d) => `translate(${d.x},${d.y})`);
          memberElements.attr("width", (d) => d.width).attr("height", (d) => d.height);
          memberElements.attr("x", (d) => d.cx).attr("y", (d) => d.cy);
        });

        // recursive inner simulation.
        for (let i = 0; i < nodes.length; i++) {
          if (nodes[i].members) {
            createInnerSimulation(nodes[i].members, canvas, allSimulation, nodes[i]);
          }
        }
      }
    </script>
  </body>
</html>
